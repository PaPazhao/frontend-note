(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{439:function(r,e,_){"use strict";_.r(e);var v=_(2),t=Object(v.a)({},(function(){var r=this,e=r._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("h2",{attrs:{id:"错误"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#错误"}},[r._v("#")]),r._v(" 错误")]),r._v(" "),e("h2",{attrs:{id:"_11-errorcaptured"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11-errorcaptured"}},[r._v("#")]),r._v(" 11. errorCaptured")]),r._v(" "),e("p",[r._v("捕获后代组件传递的错误时调用")]),r._v(" "),e("p",[r._v("错误可以自从下面几个来源捕获:")]),r._v(" "),e("ul",[e("li",[r._v("组件渲染")]),r._v(" "),e("li",[r._v("事件处理器")]),r._v(" "),e("li",[r._v("生命周期钩子")]),r._v(" "),e("li",[e("code",[r._v("setup")]),r._v(" 函数")]),r._v(" "),e("li",[r._v("侦听器")]),r._v(" "),e("li",[r._v("自定义指令钩子")]),r._v(" "),e("li",[r._v("过度钩子")])]),r._v(" "),e("p",[r._v("这个钩子带有三个实参：错误对象、触发该错误的组件实例，以及一个说明错误来源类型的信息字符串。")]),r._v(" "),e("p",[r._v("你可以在 errorCaptured() 中更改组件状态来为用户显示一个错误状态。然而重要的是，不要让错误状态渲染为导致本次错误的内容，否则组件就会进入无限的渲染循环中。")]),r._v(" "),e("p",[r._v("这个钩子可以通过返回 false 来阻止错误继续向上传递。请看下方的传递细节介绍。")]),r._v(" "),e("p",[r._v("错误传递规则")]),r._v(" "),e("p",[r._v("默认情况下，所有的错误都会被发送到应用级的 app.config.errorHandler (前提是这个函数已经定义)，这样这些错误都能在一个统一的地方报告给分析服务。")]),r._v(" "),e("p",[r._v("如果组件的继承链或组件链上存在多个 errorCaptured 钩子，对于同一个错误，这些钩子会被按从底至上的顺序一一调用。这个过程被称为“向上传递”，类似于原生 DOM 事件的冒泡机制。")]),r._v(" "),e("p",[r._v("如果 errorCaptured 钩子本身抛出了一个错误，那么这个错误和原来捕获到的错误都将被发送到 app.config.errorHandler。")]),r._v(" "),e("p",[r._v("errorCaptured 钩子可以通过返回 false 来阻止错误继续向上传递。即表示“这个错误已经被处理了，应当被忽略”，它将阻止其他的 errorCaptured 钩子或 app.config.errorHandler 因这个错误而被调用。")]),r._v(" "),e("p",[r._v("renderTracked\nrenderTriggered\nserverPrefetch")])])}),[],!1,null,null,null);e.default=t.exports}}]);